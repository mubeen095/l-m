{"id":2843,"date":"2024-01-25T12:10:41","date_gmt":"2024-01-25T12:10:41","guid":{"rendered":"https:\/\/www.skillvertex.com\/blog\/?p=2843"},"modified":"2024-01-25T12:10:41","modified_gmt":"2024-01-25T12:10:41","slug":"storage-classes-in-c","status":"publish","type":"post","link":"https:\/\/www.skillvertex.com\/blog\/storage-classes-in-c\/","title":{"rendered":"Storage Classes In C"},"content":{"rendered":"\n<div class=\"wp-block-rank-math-toc-block\" id=\"rank-math-toc\" id=\"rank-math-toc\"><p>Table of Contents<\/p><nav><ul><li ><a href=\"#storage-classes-in-c\">Storage Classes In C<\/a><\/li><li ><a href=\"#1-auto\">1. auto<\/a><\/li><li ><a href=\"#2-extern\">2.extern<\/a><\/li><li ><a href=\"#3-static\">3.static<\/a><\/li><li ><a href=\"#4-register\">4. register<\/a><\/li><li ><a href=\"#example\">Example<\/a><\/li><li ><a href=\"#faq-storage-classes-in-c\">FAQ- Storage Classes In C<\/a><\/li><\/ul><\/nav><\/div>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"storage-classes-in-c\">Storage Classes In C<\/h2>\n\n\n\n<p>Storage classes in the C programming language play a fundamental role in defining how variables and functions behave within a program. These storage classes provide a mechanism to specify crucial attributes, such as scope, visibility, and lifetime, which have a significant impact on a program&#8217;s structure and execution. By understanding storage classes, programmers gain control over how memory is allocated, how variables are accessed, and how functions are utilized, allowing for more efficient and organized code. In this exploration of storage classes in C, we will delve into the different types of storage classes, their characteristics, and their practical applications, providing a comprehensive understanding of their significance in C programming.<\/p>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"1-auto\">1. auto<\/h2>\n\n\n\n<p>&#8220;auto&#8221; is the default storage class for variables declared within a function or block. These variables have local scope, meaning they are accessible only within the block or function in which they are declared. The &#8220;auto&#8221; keyword is rarely used explicitly because variables without an explicitly specified storage class are automatically considered &#8220;auto&#8221; by default. They have a limited lifetime, as they are automatically created when the block is entered and destroyed when the block exits. &#8220;auto&#8221; variables can also be accessed within nested blocks within the parent block or function in which they are declared. This makes them suitable for temporary or short-lived variables used within a specific context.<\/p>\n\n\n\n<p>While &#8220;auto&#8221; variables are typically limited in scope to the block or function in which they are declared, it&#8217;s important to note that they can technically be accessed outside their scope using pointers. If you obtain the memory address of an &#8220;auto&#8221; variable and store it in a pointer, you can access the variable&#8217;s value from other parts of the program.<\/p>\n\n\n\n<p>However, doing so can be risky and is generally discouraged because it can lead to undefined behavior and memory issues if not handled carefully. &#8220;Auto&#8221; variables are intended to be local in scope, and accessing them via pointers from outside their scope can result in unpredictable and unintended consequences.<\/p>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"2-extern\">2.extern<\/h2>\n\n\n\n<p>The description of the &#8220;extern&#8221; storage class in C is largely accurate. The &#8220;extern&#8221; keyword is used to indicate that a variable is defined elsewhere, typically in a different file or translation unit, and not within the same block or function where it is used. The main characteristics of &#8220;extern&#8221; variables are as follows:<\/p>\n\n\n\n<ol class=\"wp-block-list\">\n<li><strong>Global Access<\/strong>: &#8220;extern&#8221; variables are global in scope, meaning they can be accessed from any function or block within the same program.<\/li>\n\n\n\n<li><strong>Legal Initialization<\/strong>: While &#8220;extern&#8221; variables are declared in one file, they are often initialized with a legal value in another file or translation unit. This allows variables to be shared and used across different parts of a program.<\/li>\n\n\n\n<li><strong>No Memory Allocation<\/strong>: &#8220;extern&#8221; variables do not allocate memory for the variable itself; instead, they refer to an existing variable defined elsewhere. This is important because it avoids redundancy and ensures that there is only one instance of the variable in memory.<\/li>\n\n\n\n<li><strong>Linking Files<\/strong>: One of the primary purposes of using &#8220;extern&#8221; variables is to enable communication between different source code files in a large program. This allows different parts of the program to share data and variables.<\/li>\n<\/ol>\n\n\n\n<p>Additionally, the statement correctly mentions that you can declare a global variable as &#8220;extern&#8221; in a local block or function, indicating that you are not creating a new variable but instead using the global variable. This is a way to access global variables from within a specific context.<\/p>\n\n\n\n<p>Overall, &#8220;extern&#8221; is a crucial concept for inter-file communication and sharing variables in C programs.<\/p>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"3-static\">3.static<\/h2>\n\n\n\n<p>Static variables have some distinctive properties, and your statement captures many of them. Here&#8217;s a breakdown of the key points mentioned:<\/p>\n\n\n\n<ol class=\"wp-block-list\">\n<li><strong>Preservation of Value<\/strong>: Static variables preserve their values between function calls. They retain the value of their last use within their scope, even after going out of scope. This makes them useful for maintaining state across multiple calls.<\/li>\n\n\n\n<li><strong>Initialization<\/strong>: Static variables are initialized only once, typically with a default value of 0 by the compiler. You can provide an explicit initialization value if needed.<\/li>\n\n\n\n<li><strong>Lifetime<\/strong>: They exist for the entire duration of the program, from the moment they are initialized until the program terminates. No new memory is allocated for them because they are not re-declared.<\/li>\n\n\n\n<li><strong>Scope<\/strong>: Static variables have local scope within the function in which they are defined. This means they are accessible only within that specific function. Global static variables, declared outside any function, can be accessed from anywhere in the program but are limited to that program&#8217;s file.<\/li>\n<\/ol>\n\n\n\n<p>These characteristics make static variables valuable for certain programming scenarios, such as maintaining counters or tracking state across function calls, without the need for global variables.<\/p>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"4-register\">4. register<\/h2>\n\n\n\n<p> Register variables are a type of storage class that is intended for optimization, and your statement highlights the key points associated with them:<\/p>\n\n\n\n<ol class=\"wp-block-list\">\n<li><strong>Use of Registers<\/strong>: Register variables are similar to auto variables but come with an optimization aspect. The compiler attempts to store these variables in CPU registers if registers are available. This is because CPU registers are faster to access than variables stored in memory.<\/li>\n\n\n\n<li><strong>Falling Back to Memory<\/strong>: If there are no available CPU registers (registers are limited resources), the compiler will fall back to storing these variables in memory.<\/li>\n\n\n\n<li><strong>Performance Improvement<\/strong>: Register variables can improve the running time of a program when used for variables that are accessed frequently because reading from and writing to CPU registers is faster than accessing variables in memory.<\/li>\n\n\n\n<li><strong>Address Inaccessibility<\/strong>: As you correctly mentioned, it&#8217;s important to note that you cannot obtain the address of a register variable using pointers. Register variables are not addressable because they are intended to be stored in CPU registers, and CPU registers do not have memory addresses that are accessible to the programmer.<\/li>\n<\/ol>\n\n\n\n<p>However, it&#8217;s worth mentioning that modern optimizing compilers are quite effective at managing variable storage and register allocation. In many cases, explicit use of the &#8220;register&#8221; keyword may not be necessary, as compilers can automatically optimize variable storage for performance.<\/p>\n\n\n\n<p><strong>Syntax<\/strong><\/p>\n\n\n\n<p>Syntax of storage class of variable is given below:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>storage_class var_data_type var_name;\n<\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"example\">Example<\/h2>\n\n\n\n<pre class=\"wp-block-code\"><code>\/ A C program to demonstrate different storage \n\/\/ classes \n#include &lt;stdio.h&gt; \n  \n\/\/ declaring the variable which is to be made extern \n\/\/ an initial value can also be initialized to x \nint x; \n  \nvoid autoStorageClass() \n{ \n  \n    printf(\"\\nDemonstrating auto class\\n\\n\"); \n  \n    \/\/ declaring an auto variable (simply \n    \/\/ writing \"int a=32;\" works as well) \n    auto int a = 32; \n  \n    \/\/ printing the auto variable 'a' \n    printf(\"Value of the variable 'a'\"\n           \" declared as auto: %d\\n\", \n           a); \n  \n    printf(\"--------------------------------\"); \n} \nvoid registerStorageClass() \n{ \n  \n    printf(\"\\nDemonstrating register class\\n\\n\"); \n  \n    \/\/ declaring a register variable \n    register char b = 'G'; \n  \n    \/\/ printing the register variable 'b' \n    printf(\"Value of the variable 'b'\"\n           \" declared as register: %d\\n\", \n           b); \n  \n    printf(\"--------------------------------\"); \n} \n  \nvoid externStorageClass() \n{ \n  printf(\"\\nDemonstrating extern class\\n\\n\"); \n  \n    \/\/ telling the compiler that the variable \n    \/\/ x is an extern variable and has been \n    \/\/ defined elsewhere (above the main \n    \/\/ function) \n    extern int x; \n  \n    \/\/ printing the extern variables 'x' \n    printf(\"Value of the variable 'x'\"\n           \" declared as extern: %d\\n\", \n           x); \n  \n    \/\/ value of extern variable x modified \n    x = 2; \n  \n    \/\/ printing the modified values of \n    \/\/ extern variables 'x' \n    printf(\"Modified value of the variable 'x'\"\n           \" declared as extern: %d\\n\", \n           x); \nprintf(\"--------------------------------\"); \n} \n  \nvoid staticStorageClass() \n{ \n    int i = 0; \n  \n    printf(\"\\nDemonstrating static class\\n\\n\"); \n  \n    \/\/ using a static variable 'y' \n    printf(\"Declaring 'y' as static inside the loop.\\n\"\n           \"But this declaration will occur only\"\n           \" once as 'y' is static.\\n\"\n           \"If not, then every time the value of 'y' \"\n           \"will be the declared value 5\"\n           \" as in the case of variable 'p'\\n\"); \n  \n    printf(\"\\nLoop started:\\n\"); \n  \n    for (i = 1; i &lt; 5; i++) { \n  \n        \/\/ Declaring the static variable 'y' \n        static int y = 5; \n  \n        \/\/ Declare a non-static variable 'p' \n        int p = 10; \n\/\/ Incrementing the value of y and p by 1 \n        y++; \n        p++; \n  \n        \/\/ printing value of y at each iteration \n        printf(\"\\nThe value of 'y', \"\n               \"declared as static, in %d \"\n               \"iteration is %d\\n\", \n               i, y); \n  \n        \/\/ printing value of p at each iteration \n        printf(\"The value of non-static variable 'p', \"\n               \"in %d iteration is %d\\n\", \n               i, p); \n    } \n  \n    printf(\"\\nLoop ended:\\n\"); \n  \n    printf(\"--------------------------------\"); \n} \n  \nint main() \n{ \n  \n    printf(\"A program to demonstrate\"\n\" Storage Classes in C\\n\\n\"); \n  \n    \/\/ To demonstrate auto Storage Class \n    autoStorageClass(); \n  \n    \/\/ To demonstrate register Storage Class \n    registerStorageClass(); \n  \n    \/\/ To demonstrate extern Storage Class \n    externStorageClass(); \n  \n    \/\/ To demonstrate static Storage Class \n    staticStorageClass(); \n  \n    \/\/ exiting \n    printf(\"\\n\\nStorage Classes demonstrated\"); \n  \n    return 0; \n} <\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>A program to demonstrate Storage Classes in C\n\n\nDemonstrating auto class\n\nValue of the variable 'a' declared as auto: 32\n--------------------------------\nDemonstrating register class\n\nValue of the variable 'b' declared as register: 71\n--------------------------------\nDemonstrating extern class\nValue of the variable 'x' declared as extern: 0\nModified value of the variable 'x' declared as extern: 2\n--------------------------------\nDemonstrating static class\n\nDeclaring 'y' as static inside the loop.\nBut this declaration will occur only once as 'y' is static.\nIf not, then every time the value of 'y' will be the declared value 5 as in the case of variable 'p'\n\nLoop started:\n\nThe value of 'y', declared as static, in 1 iteration is 6\nThe value of non-static variable 'p', in 1 iteration is 11\n\nThe value of 'y', declared as static, in 2 iteration is 7\nThe value of non-static variable 'p', in 2 iteration is 11\n\nThe value of 'y', declared as static, in 3 iteration is 8\nThe value of non-static variable 'p', in 3 iteration is 11\n\nThe value of 'y', declared as static, in 4 iteration is 9\nThe value of non-static variable 'p', in 4 iteration is 11\n\nLoop ended:\n--------------------------------<\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"faq-storage-classes-in-c\">FAQ- Storage Classes In C<\/h2>\n\n\n<div id=\"rank-math-faq\" class=\"rank-math-block\">\n<div class=\"rank-math-list \">\n<div id=\"faq-question-1698046544177\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q1. What are the storage classes in C?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. <strong>There are four different types of storage classes that we use in the C language:<\/strong><br \/>Automatic Storage Class.<br \/>External Storage Class.<br \/>Static Storage Class.<br \/>Register Storage Class.<\/p>\n\n<\/div>\n<\/div>\n<div id=\"faq-question-1698046549258\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q2. What is storage class in C example?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. The storage classes in the C programming language serve as descriptors for variables and functions, encapsulating key attributes. These attributes primarily encompass scope, visibility, and lifetime, collectively aiding in the monitoring of a variable&#8217;s existence during a program&#8217;s runtime.<\/p>\n\n<\/div>\n<\/div>\n<div id=\"faq-question-1698046556665\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q3. What is storage class and types?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. Storage classes in C encompass both the scope and the lifespan of a variable. They also define the accessibility of variables and their locations within a program. C provides four main storage classes: auto, register, extern, and static. These storage classes play a fundamental role in determining how variables behave and are accessed in a program.<\/p>\n\n<\/div>\n<\/div>\n<\/div>\n<\/div>","protected":false},"excerpt":{"rendered":"<p>Storage Classes In C Storage classes in the C programming language play a fundamental role in defining how variables and functions behave within a program. These storage classes provide a mechanism to specify crucial attributes, such as scope, visibility, and lifetime, which have a significant impact on a program&#8217;s structure and execution. By understanding storage &#8230; <a title=\"Storage Classes In C\" class=\"read-more\" href=\"https:\/\/www.skillvertex.com\/blog\/storage-classes-in-c\/\" aria-label=\"More on Storage Classes In C\">Read more<\/a><\/p>\n","protected":false},"author":4,"featured_media":2845,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[28],"tags":[494],"class_list":["post-2843","post","type-post","status-publish","format-standard","has-post-thumbnail","hentry","category-cpp-programming","tag-storage-classes-in-c","generate-columns","tablet-grid-50","mobile-grid-100","grid-parent","grid-33"],"_links":{"self":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/2843"}],"collection":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/comments?post=2843"}],"version-history":[{"count":2,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/2843\/revisions"}],"predecessor-version":[{"id":6849,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/2843\/revisions\/6849"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/media\/2845"}],"wp:attachment":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/media?parent=2843"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/categories?post=2843"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/tags?post=2843"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}