{"id":3076,"date":"2024-05-10T11:36:24","date_gmt":"2024-05-10T11:36:24","guid":{"rendered":"https:\/\/www.skillvertex.com\/blog\/?p=3076"},"modified":"2024-05-10T11:36:24","modified_gmt":"2024-05-10T11:36:24","slug":"memory-layout-of-c-programs","status":"publish","type":"post","link":"https:\/\/www.skillvertex.com\/blog\/memory-layout-of-c-programs\/","title":{"rendered":"Memory Layout of C Programs"},"content":{"rendered":"\n<div class=\"wp-block-rank-math-toc-block\" id=\"rank-math-toc\" id=\"rank-math-toc\"><p>Table of Contents<\/p><nav><ul><li ><a href=\"#memory-layout-of-c-programs\">Memory Layout of C Programs<\/a><\/li><li ><a href=\"#examples\">Examples:<\/a><\/li><li ><a href=\"#1-check-the-following-simple-c-program\">1. Check the following simple C program\u00a0<\/a><\/li><li ><a href=\"#2-we-can-add-one-global-variable-in-the-program-and-then-check-the-size-of-bss-highlighted-in-red-color\">2. We can add one global variable in the program, and then check the size of bss (highlighted in red color).<\/a><\/li><li ><a href=\"#3-we-can-add-one-static-variable-which-is-also-stored-in-bss\">3. We can add one static variable which is also stored in bss.<\/a><\/li><li ><a href=\"#4-we-can-initialize-the-static-variable-which-can-be-stored-in-the-data-segment-ds\">4. We can  initialize the static variable which can  be stored in the Data Segment (DS)<\/a><\/li><li ><a href=\"#5-we-can-initialize-the-global-variable-which-can-be-stored-in-the-data-segment-ds\">5. We can  initialize the global variable which can be stored in the Data Segment (DS)<\/a><\/li><li ><a href=\"#faq-memory-layout-of-c-programs\">FAQ- Memory Layout of C Programs<\/a><\/li><\/ul><\/nav><\/div>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"memory-layout-of-c-programs\">Memory Layout of C Programs<\/h2>\n\n\n\n<p>A typical memory representation of a C program consists of the following sections.<\/p>\n\n\n\n<ol class=\"wp-block-list\">\n<li>Text segment&nbsp; (i.e. instructions)<\/li>\n\n\n\n<li>Initialized data segment&nbsp;<\/li>\n\n\n\n<li>Uninitialized data segment&nbsp; (bss)<\/li>\n\n\n\n<li>Heap&nbsp;<\/li>\n\n\n\n<li>Stack&nbsp;<\/li>\n<\/ol>\n\n\n\n<p><strong>Text Segment<\/strong>: The text segment in the memory layout of a running process is accurate. The text segment, also known as the code segment, is a section of a program in memory that contains the executable instructions of the program. It is where the machine code generated by the compiler is stored, and these instructions are executed by the CPU.<\/p>\n\n\n\n<p>Additionally, your mention of placing the text segment below the heap and stack is generally correct. The text segment is typically positioned in memory before the heap and stack to prevent them from overwriting it. Placing it in this manner helps ensure the integrity of the executable code and prevents unintended memory corruption.<\/p>\n\n\n\n<p>The text segment in a running process is often shareable among multiple instances of the same program to save memory. It&#8217;s also marked as read-only to prevent accidental modification of program instructions.<\/p>\n\n\n\n<p>2 . <strong>Initialized Data Segment<\/strong>: The Initialized Data Segment, also known as the Data Segment, contains global and static variables that are initialized by the programmer. It&#8217;s not read-only, as variable values can be changed during runtime. This segment is further divided into initialized read-only and initialized read-write areas. For example, a global string-like <code>char s[] = \"hello world\"<\/code> and a statement-like <code>int debug = 1<\/code> would be in the initialized read-write area. A statement  <code>const char* string = \"hello world\"<\/code> places the string literal in the initialized read-only area and the character pointer variable in the initialized read-write area. Variables like <code>static int i = 10<\/code> and <code>global int i = 10<\/code> are stored in the data segment.<\/p>\n\n\n\n<p><strong>3. Uninitialized Data Segment:<\/strong>&nbsp;The Uninitialized Data Segment, often referred to as the &#8220;bss&#8221; segment, gets its name from an old assembler operator, &#8220;block started by symbol.&#8221; In this segment, the kernel initializes data to zero before the program starts running. It includes global and static variables that are either explicitly set to zero or lack explicit initialization in the source code. Examples of variables placed in the BSS segment include <code>static int i;<\/code> and <code>int j;<\/code>.<\/p>\n\n\n\n<p>4.<strong> Stack: <\/strong>The Stack is a region in memory that traditionally grows in the opposite direction of the heap. It contains the program stack, which is a Last-In-First-Out (LIFO) structure, usually located in the higher parts of memory. On the x86 PC architecture, it grows towards address zero; on some other architectures, it grows in the opposite direction. A &#8220;stack pointer&#8221; register keeps track of the top of the stack and is adjusted each time a value is &#8220;pushed&#8221; onto the stack. Each function call corresponds to a &#8220;stack frame&#8221; that includes, at a minimum, a return address.<\/p>\n\n\n\n<p>In the stack, automatic variables are stored, and it also holds information saved each time a function is called. When a function is called, the address to return to and information about the caller&#8217;s environment, such as machine registers, are saved on the stack. The newly called function allocates space on the stack for its automatic variables. This mechanism is how recursive functions in C can work, as each recursive call uses a new stack frame, preventing interference between variables from different instances of the function.<\/p>\n\n\n\n<p>5.<strong> Heap<\/strong>: The Heap is the memory segment where dynamic memory allocation typically occurs. It starts at the end of the BSS segment and grows toward larger memory addresses. Memory allocation functions like malloc, realloc, and free manage the heap. These functions may use system calls like brk and sbrk to adjust the heap&#8217;s size. It&#8217;s important to note that the use of brk\/sbrk and a single contiguous &#8220;heap area&#8221; is not mandatory for memory allocation; implementations may also be used <code>mmap<\/code> to reserve potentially non-contiguous regions of virtual memory. The Heap area is shared by all shared libraries and dynamically loaded modules within a process.<\/p>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"examples\">Examples:<\/h2>\n\n\n\n<p>The size(1) command reports the sizes (in bytes) of the text, data, and bss segments. ( for more details please refer man page of size(1) )<\/p>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"1-check-the-following-simple-c-program\">1. Check the following simple C program&nbsp;<\/h2>\n\n\n\n<pre class=\"wp-block-code\"><code>\n#include &lt;stdio.h&gt;\n \nint main(void)\n{\n    return 0;\n}<\/code><\/pre>\n\n\n\n<pre class=\"wp-block-code\"><code>&#91;narendra@CentOS]$ gcc memory-layout.c -o memory-layout\n&#91;narendra@CentOS]$ size memory-layout\ntext       data        bss        dec        hex    filename\n960        248          8       1216        4c0    memory-layout<\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"2-we-can-add-one-global-variable-in-the-program-and-then-check-the-size-of-bss-highlighted-in-red-color\">2. We can add one global variable in the program, and then check the size of bss (highlighted in red color).<\/h2>\n\n\n\n<pre class=\"wp-block-code\"><code>\n#include &lt;stdio.h&gt;\n \nint global; \/* Uninitialized variable stored in bss*\/\n \nint main(void)\n{\n    return 0;\n}<\/code><\/pre>\n\n\n\n<pre class=\"wp-block-code\"><code>&#91;narendra@CentOS]$ gcc memory-layout.c -o memory-layout\n&#91;narendra@CentOS]$ size memory-layout\ntext       data        bss        dec        hex    filename\n 960        248         12       1220        4c4    memory-layout<\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"3-we-can-add-one-static-variable-which-is-also-stored-in-bss\">3. We can add one static variable which is also stored in bss.<\/h2>\n\n\n\n<pre class=\"wp-block-code\"><code>#include &lt;stdio.h&gt;\n \nint global; \/* Uninitialized variable stored in bss*\/\n \nint main(void)\n{\n    static int i; \/* Uninitialized static variable stored in bss *\/\n    return 0;\n}<\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"4-we-can-initialize-the-static-variable-which-can-be-stored-in-the-data-segment-ds\">4. We can  initialize the static variable which can  be stored in the Data Segment (DS)<\/h2>\n\n\n\n<pre class=\"wp-block-code\"><code>\n#include &lt;stdio.h&gt;\n \nint global; \/* Uninitialized variable stored in bss*\/\n \nint main(void)\n{\n    static int i = 100; \/* Initialized static variable stored in DS*\/\n    return 0;\n}<\/code><\/pre>\n\n\n\n<pre class=\"wp-block-code\"><code>&#91;narendra@CentOS]$ gcc memory-layout.c -o memory-layout\n&#91;narendra@CentOS]$ size memory-layout\ntext       data        bss        dec        hex    filename\n960         252         12       1224        4c8    memory-layout<\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"5-we-can-initialize-the-global-variable-which-can-be-stored-in-the-data-segment-ds\">5. We can  initialize the global variable which can be stored in the Data Segment (DS)<\/h2>\n\n\n\n<pre class=\"wp-block-code\"><code>\n#include &lt;stdio.h&gt;\n \nint global = 10; \/* initialized global variable stored in DS*\/\n \nint main(void)\n{\n    static int i = 100; \/* Initialized static variable stored in DS*\/\n    return 0;\n}<\/code><\/pre>\n\n\n\n<pre class=\"wp-block-code\"><code>&#91;narendra@CentOS]$ gcc memory-layout.c -o memory-layout\n&#91;narendra@CentOS]$ size memory-layout\ntext       data        bss        dec        hex    filename\n960         256          8       1224        4c8    memory-layout<\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"faq-memory-layout-of-c-programs\">FAQ- Memory Layout of C Programs<\/h2>\n\n\n<div id=\"rank-math-faq\" class=\"rank-math-block\">\n<div class=\"rank-math-list \">\n<div id=\"faq-question-1698320665336\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q1. What is memory layout in the C program?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. The memory layout of a C program after being loaded into RAM typically includes six components: text segment, initialized data segment, uninitialized data segment, command-line arguments, stack, and heap. <\/p>\n\n<\/div>\n<\/div>\n<div id=\"faq-question-1698320679558\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q2. What is the heap memory layout in C?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. Heap memory is used for dynamic memory allocation in C and other programming languages. It typically begins immediately after the uninitialized data segment and grows upwards to higher memory addresses. The <code>malloc()<\/code> and <code>calloc()<\/code> functions in C are commonly used to allocate memory in the heap. These functions allow the program to request and manage memory dynamically at runtime, which is particularly useful when you need to work with data structures of varying sizes or when the memory requirements are not known at compile time.<\/p>\n\n<\/div>\n<\/div>\n<div id=\"faq-question-1698320686980\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q3. What is the memory layout of arrays?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. In multi-dimensional arrays, elements can be stored in two ways: column-major layout, where columns are contiguous in memory, or row-major layout, where rows are contiguous. This arrangement is also known as column-major order and row-major order, respectively. The choice depends on the programming language and can impact memory access efficiency.<\/p>\n\n<\/div>\n<\/div>\n<\/div>\n<\/div>","protected":false},"excerpt":{"rendered":"<p>Memory Layout of C Programs A typical memory representation of a C program consists of the following sections. Text Segment: The text segment in the memory layout of a running process is accurate. The text segment, also known as the code segment, is a section of a program in memory that contains the executable instructions &#8230; <a title=\"Memory Layout of C Programs\" class=\"read-more\" href=\"https:\/\/www.skillvertex.com\/blog\/memory-layout-of-c-programs\/\" aria-label=\"More on Memory Layout of C Programs\">Read more<\/a><\/p>\n","protected":false},"author":4,"featured_media":3080,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[224],"tags":[508],"class_list":["post-3076","post","type-post","status-publish","format-standard","has-post-thumbnail","hentry","category-question-answer","tag-memory-layout-of-c-programs","generate-columns","tablet-grid-50","mobile-grid-100","grid-parent","grid-33"],"_links":{"self":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/3076"}],"collection":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/comments?post=3076"}],"version-history":[{"count":6,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/3076\/revisions"}],"predecessor-version":[{"id":10746,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/3076\/revisions\/10746"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/media\/3080"}],"wp:attachment":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/media?parent=3076"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/categories?post=3076"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/tags?post=3076"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}