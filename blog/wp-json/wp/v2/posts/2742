{"id":2742,"date":"2024-05-10T11:23:40","date_gmt":"2024-05-10T11:23:40","guid":{"rendered":"https:\/\/www.skillvertex.com\/blog\/?p=2742"},"modified":"2024-05-10T11:23:40","modified_gmt":"2024-05-10T11:23:40","slug":"dangling-void-null-and-wild-pointers","status":"publish","type":"post","link":"https:\/\/www.skillvertex.com\/blog\/dangling-void-null-and-wild-pointers\/","title":{"rendered":"Dangling, Void , Null ,And Wild Pointers"},"content":{"rendered":"\n<div class=\"wp-block-rank-math-toc-block\" id=\"rank-math-toc\" id=\"rank-math-toc\"><p>Table of Contents<\/p><nav><ul><li ><a href=\"#dangling-void-null-and-wild-pointers\">Dangling, Void, Null, And Wild Pointers<\/a><\/li><li ><a href=\"#1-de-allocation-of-memory\">1. De-allocation of memory<\/a><\/li><li ><a href=\"#2-function-call\">2. Function Call<\/a><\/li><li ><a href=\"#3-variable-goes-out-of-scope\">3. Variable goes out of scope\u00a0<\/a><\/li><li ><a href=\"#void-pointer\">Void Pointer<\/a><\/li><li ><a href=\"#null-pointer\">Null Pointer<\/a><\/li><li ><a href=\"#wild-pointer\">Wild Pointer<\/a><\/li><li ><a href=\"#faq-dangling-void-null-and-wild-pointers\">FAQ- Dangling, Void , Null and Wild Pointers<\/a><\/li><\/ul><\/nav><\/div>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"dangling-void-null-and-wild-pointers\">Dangling, Void, Null, And Wild Pointers<\/h2>\n\n\n\n<p>A &#8220;dangling pointer&#8221; is when a pointer points to a place that&#8217;s no longer valid. This can occur in three different situations:<\/p>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"1-de-allocation-of-memory\">1. De-allocation of memory<\/h2>\n\n\n\n<pre class=\"wp-block-code\"><code>\n\/\/ Deallocating a memory pointed by ptr causes\n\/\/ dangling pointer\n \n#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n \nint main()\n{\n    int* ptr = (int *)malloc(sizeof(int));\n \n    \/\/ After below free call, ptr becomes a \n    \/\/ dangling pointer\n    free(ptr); \n     \n    \/\/ No more  dangling pointer\n    ptr = NULL;\n}\n <\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"2-function-call\">2. Function Call<\/h2>\n\n\n\n<pre class=\"wp-block-code\"><code>\n\n\/\/ The pointer pointing to local variable becomes\n\/\/ dangling when local variable is not static.\n \n#include &lt;iostream&gt;\n   \nint* fun()\n{\n    \/\/ x is local variable and goes out of\n    \/\/ scope after an execution of fun() is\n    \/\/ over.\n    int x = 5;\n   \n    return &amp;x;\n}\n   \n\/\/ Driver Code\nint main()\n{\n    int *p = fun();\n    fflush(stdin);\n   \n    \/\/ p points to something which is not\n    \/\/ valid anymore\n    std::cout &lt;&lt; *p;\n   \n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>0<\/code><\/pre>\n\n\n\n<p>Whereas, if x is a static variable, then the problem that occurs in the above program won&#8217;t happen.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\/\/ The pointer pointing to local variable doesn't\n\/\/ become dangling when local variable is static.\n \n#include &lt;iostream&gt;\nusing namespace std;\n \nint *fun()\n{\n    \/\/ x now has scope throughout the program\n    static int x = 5;\n \n    return &amp;x;\n}\n \nint main()\n{\n    int *p = fun();\n    fflush(stdin);\n     \n    \/\/ Not a dangling pointer as it points\n    \/\/ to static variable.\n    cout &lt;&lt; *p;\n     \n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>5<\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"3-variable-goes-out-of-scope\">3. Variable goes out of scope&nbsp;<\/h2>\n\n\n\n<pre class=\"wp-block-code\"><code>void main()\n{\n   int *ptr;\n   .....\n   .....\n   {\n       int ch;\n       ptr = &amp;ch;\n   } \n   .....   \n   \/\/ Here ptr is dangling pointer\n}<\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"void-pointer\">Void Pointer<\/h2>\n\n\n\n<p>A &#8220;void pointer&#8221; (void *) is a special kind of pointer that doesn&#8217;t have a specific data type. It can point to data of any type. If you assign it the address of a char, it becomes a char pointer; if you assign it an int address, it&#8217;s an int pointer, and so on. You can convert any pointer type to a void pointer, allowing it to point to any value.<\/p>\n\n\n\n<p>Some key points to remember:<\/p>\n\n\n\n<ul class=\"wp-block-list\">\n<li>You can&#8217;t directly access the data pointed to by a void pointer; you need to typecast it to the appropriate data type first.<\/li>\n\n\n\n<li>You can&#8217;t perform pointer arithmetic on void pointers because they lack a specific size and concrete data type.<\/li>\n<\/ul>\n\n\n\n<p>Example<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\n\n#include &lt;stdlib.h&gt;\n \nint main()\n{\n    int x = 4;\n    float y = 5.5;\n \n    \/\/ A void pointer\n    void* ptr;\n    ptr = &amp;x;\n \n    \/\/ (int*)ptr - does type casting of void\n    \/\/ *((int*)ptr) dereferences the typecasted\n    \/\/ void pointer variable.\n    printf(\"Integer variable is = %d\", *((int*)ptr));\n \n    \/\/ void pointer is now float\n    ptr = &amp;y;\n    printf(\"\\nFloat variable is = %f\", *((float*)ptr));\n \n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>Integer variable is = 4\nFloat variable is = 5.500000<\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"null-pointer\">Null Pointer<\/h2>\n\n\n\n<p>A &#8220;NULL Pointer&#8221; is like a pointer that points to nothing. When you don&#8217;t have a specific address to assign to a pointer, you can use NULL to indicate that it&#8217;s not pointing to anything.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\n\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main()\n{\n    \/\/ Null Pointer\n    int *ptr = NULL;\n     \n    cout &lt;&lt; \"The value of ptr is \" &lt;&lt; ptr;\n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>The value of ptr is 0\n<\/code><\/pre>\n\n\n\n<p>Important Points:<\/p>\n\n\n\n<ol class=\"wp-block-list\">\n<li><strong>NULL Pointer vs. Uninitialized Pointer<\/strong>:<\/li>\n<\/ol>\n\n\n\n<ul class=\"wp-block-list\">\n<li>An uninitialized pointer contains an undefined value, which means it&#8217;s pointing to a random or unpredictable memory location.<\/li>\n\n\n\n<li>A NULL pointer contains a defined value that is intentionally set to indicate it&#8217;s not pointing to a valid memory location.<\/li>\n<\/ul>\n\n\n\n<p>      2. <strong>NULL Pointer vs. Void Pointer<\/strong>:<\/p>\n\n\n\n<ul class=\"wp-block-list\">\n<li>A NULL pointer is a specific value, indicating that a pointer doesn&#8217;t point to a valid address.<\/li>\n\n\n\n<li>A void pointer is a data type that doesn&#8217;t specify any particular data type, but it&#8217;s used to point to data of any type.<\/li>\n<\/ul>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"wild-pointer\">Wild Pointer<\/h2>\n\n\n\n<p>A &#8220;wild pointer&#8221; is a pointer that hasn&#8217;t been set to any specific value, not even NULL. It might start with a random or garbage value that doesn&#8217;t necessarily point to a valid memory address.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\nint main()\n{\n    int *p;  \/* wild pointer *\/\n \n    int x = 10;\n \n    \/\/ p is not a wild pointer now\n    p = &amp;x;\n \n    return 0;\n}<\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"faq-dangling-void-null-and-wild-pointers\">FAQ- Dangling, Void , Null and Wild Pointers<\/h2>\n\n\n<div id=\"rank-math-faq\" class=\"rank-math-block\">\n<div class=\"rank-math-list \">\n<div id=\"faq-question-1697535531785\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q1. What is meant by dangling pointer and null pointer?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans.<br \/>A &#8220;null pointer&#8221; doesn&#8217;t point to any memory location; it&#8217;s intentionally set to indicate &#8220;nothing.&#8221;<br \/>A &#8220;dangling pointer&#8221; points to a memory location that used to be valid but has been deallocated or freed, making it potentially unsafe to use.<\/p>\n\n<\/div>\n<\/div>\n<div id=\"faq-question-1697535545699\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q2. What is the use of dangling pointer in C++?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. &#8220;Dangling pointers&#8221; occur when you have pointers in your program that are still there in the stack, but they&#8217;re pointing to memory that is no longer valid or has been deallocated.<\/p>\n\n<\/div>\n<\/div>\n<div id=\"faq-question-1697535554455\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q3. What is void pointer in C?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. In C, a &#8220;void pointer&#8221; is a special type of pointer that doesn&#8217;t have a specific data type associated with it. It can point to a location in memory where data is stored, but the data type is not specified.<\/p>\n\n<\/div>\n<\/div>\n<\/div>\n<\/div>","protected":false},"excerpt":{"rendered":"<p>Dangling, Void, Null, And Wild Pointers A &#8220;dangling pointer&#8221; is when a pointer points to a place that&#8217;s no longer valid. This can occur in three different situations: 1. De-allocation of memory 2. Function Call Output Whereas, if x is a static variable, then the problem that occurs in the above program won&#8217;t happen. Output &#8230; <a title=\"Dangling, Void , Null ,And Wild Pointers\" class=\"read-more\" href=\"https:\/\/www.skillvertex.com\/blog\/dangling-void-null-and-wild-pointers\/\" aria-label=\"More on Dangling, Void , Null ,And Wild Pointers\">Read more<\/a><\/p>\n","protected":false},"author":4,"featured_media":5379,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[27],"tags":[470,471],"class_list":["post-2742","post","type-post","status-publish","format-standard","has-post-thumbnail","hentry","category-c-programming","tag-dangling","tag-void","generate-columns","tablet-grid-50","mobile-grid-100","grid-parent","grid-33"],"_links":{"self":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/2742"}],"collection":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/comments?post=2742"}],"version-history":[{"count":14,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/2742\/revisions"}],"predecessor-version":[{"id":10731,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/2742\/revisions\/10731"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/media\/5379"}],"wp:attachment":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/media?parent=2742"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/categories?post=2742"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/tags?post=2742"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}